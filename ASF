#include <asf.h>
#include "SEGGER_RTT.h"

#define I2C_SLAVE_ADDRESS 0x49 // Уникальный адрес I2C слейва

struct i2c_slave_module i2c_slave_instance;

void configure_i2c_pins(void) {
    struct system_pinmux_config pin_config;
    system_pinmux_get_config_defaults(&pin_config);

    // Настройка SDA (PA22) для SERCOM5_PAD0
    pin_config.mux_position = MUX_PA22D_SERCOM5_PAD0;
    pin_config.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
    system_pinmux_pin_set_config(PIN_PA22, &pin_config);

    // Настройка SCL (PA23) для SERCOM5_PAD1
    pin_config.mux_position = MUX_PA23D_SERCOM5_PAD1;
    pin_config.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
    system_pinmux_pin_set_config(PIN_PA23, &pin_config);
}

void configure_i2c_slave(void) {
    struct i2c_slave_config config;
    i2c_slave_get_config_defaults(&config);

    // Настройка адреса слейва
    config.address = I2C_SLAVE_ADDRESS;
    config.address_mode = I2C_SLAVE_ADDRESS_MODE_MASK; // 7-битный режим

    // Инициализация SERCOM5 как I2C слейва
    i2c_slave_init(&i2c_slave_instance, SERCOM5, &config);

    // Включение слейва
    i2c_slave_enable(&i2c_slave_instance);

    SEGGER_RTT_WriteString(0, "I2C Slave initialized on SERCOM5 with address 0x49\n");
}

int main(void) {
    system_init();
    SEGGER_RTT_Init();

    // Настройка пинов и I2C
    configure_i2c_pins();
    configure_i2c_slave();

    while (1) {
        __WFI(); // Ожидание прерываний
    }
}
