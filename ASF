#include "sam.h"
#include "SERCOM.h"
#include "i2c.h"
#include "Uart.h"

#define I2C_SLAVE_ADDR  0x09  // Адрес I2C Slave (0x9)
#define BUFFER_SIZE     64    // Размер буфера

volatile uint8_t i2c_buffer[BUFFER_SIZE];
volatile uint8_t buffer_index = 0;
volatile bool data_received = false;

I2C i2c(SERCOM5);
Uart uart(SERCOM5, PA21, PA20, SERCOM_RX_PAD_1, UART_TX_PAD_0);

void SERCOM5_Handler(void) {
    if (SERCOM5->I2CS.INTFLAG.bit.DRDY) {  // Данные готовы (I2C)
        if (buffer_index < BUFFER_SIZE) {
            i2c_buffer[buffer_index++] = SERCOM5->I2CS.DATA.reg;
        }
        SERCOM5->I2CS.INTFLAG.bit.DRDY = 1;
    }

    if (SERCOM5->I2CS.INTFLAG.bit.PREC) {  // Stop Condition (I2C)
        SERCOM5->I2CS.INTFLAG.bit.PREC = 1;
        data_received = true;  // Устанавливаем флаг, что данные получены
    }
}

void disable_sercom5() {
    SERCOM5->I2CS.CTRLA.bit.ENABLE = 0;
    while (SERCOM5->I2CS.SYNCBUSY.bit.ENABLE);
}

void enable_uart() {
    uart.begin(9600);
}

void send_uart_data() {
    for (uint8_t i = 0; i < buffer_index; i++) {
        uart.write(i2c_buffer[i]);
    }
    uart.write('\n');
}

int main(void) {
    SystemInit();
    i2c.setSlave(I2C_SLAVE_ADDR);  // Инициализация I2C в режиме Slave
    NVIC_EnableIRQ(SERCOM5_IRQn);

    while (1) {
        if (data_received) {
            data_received = false;
            disable_sercom5();
            enable_uart();
            send_uart_data();
        }
    }
}
