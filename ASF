#define I2C_SLAVE_ADDR  0x09  // Адрес I2C Slave (0x9)
#define BUFFER_SIZE     64    // Размер буфера

volatile uint8_t i2c_buffer[BUFFER_SIZE];
volatile uint8_t buffer_index = 0;
volatile bool data_received = false;

I2C i2c(SERCOM5);
Uart uart(SERCOM5, PA21, PA20, SERCOM_RX_PAD_1, UART_TX_PAD_0);

// Функция приема данных от мастера
void onI2CReceive(int count) {
    buffer_index = 0;
    while (i2c.available() && buffer_index < BUFFER_SIZE) {
        i2c_buffer[buffer_index++] = i2c.read();
    }
    data_received = true;
}

// Функция обработки запроса мастера (ЭХО-ответ)
void onI2CRequest() {
    for (uint8_t i = 0; i < buffer_index; i++) {
        i2c.write(i2c_buffer[i]); // Отправляем полученные данные обратно
    }
}

void process_uart() {
    uart.begin(9600);
    for (uint8_t i = 0; i < buffer_index; i++) {
        uart.write(i2c_buffer[i]);
    }
    uart.write('\n');
    uart.end();
    i2c.setSlave(I2C_SLAVE_ADDR);
}

int main(void) {
    SystemInit();
    i2c.setSlave(I2C_SLAVE_ADDR);
    
    i2c.onReceive(onI2CReceive);  // Назначаем обработчик приема
    i2c.onRequest(onI2CRequest);  // Назначаем обработчик запроса
}
