#include "sam.h"
#include "SERCOM.h"
#include "i2c.h"
#include "Uart.h"

#define I2C_SLAVE_ADDR  0x09  // Адрес I2C Slave (0x9)
#define BUFFER_SIZE     64    // Размер буфера

volatile uint8_t i2c_buffer[BUFFER_SIZE];
volatile uint8_t buffer_index = 0;
volatile bool data_received = false;

I2C i2c(SERCOM5);
Uart uart(SERCOM5, PA21, PA20, SERCOM_RX_PAD_1, UART_TX_PAD_0);

void SERCOM5_Handler(void) {
    if (SERCOM5->I2CS.INTFLAG.bit.AMATCH) {  // Если Slave получил свой адрес
        buffer_index = 0;  
        SERCOM5->I2CS.INTFLAG.bit.AMATCH = 1;  
    }

    if (SERCOM5->I2CS.INTFLAG.bit.DRDY) {  // Данные готовы (I2C)
        if (buffer_index < BUFFER_SIZE) {
            i2c_buffer[buffer_index++] = SERCOM5->I2CS.DATA.reg;
        }
        SERCOM5->I2CS.INTFLAG.bit.DRDY = 1;
    }

    if (SERCOM5->I2CS.INTFLAG.bit.PREC) {  // Stop Condition (I2C)
        SERCOM5->I2CS.INTFLAG.bit.PREC = 1;
        data_received = true;  // Устанавливаем флаг, что данные получены
    }
}

void switch_sercom5_to_uart() {
    // 1. Отключаем I2C
    SERCOM5->I2CS.CTRLA.bit.ENABLE = 0;  
    while (SERCOM5->I2CS.SYNCBUSY.bit.ENABLE);

    // 2. Переназначаем пины UART (PA20 TX, PA21 RX)
    PORT->Group[0].PINCFG[20].bit.PMUXEN = 1;
    PORT->Group[0].PMUX[20 >> 1].reg |= PORT_PMUX_PMUXE_D; // TX
    PORT->Group[0].PINCFG[21].bit.PMUXEN = 1;
    PORT->Group[0].PMUX[21 >> 1].reg |= PORT_PMUX_PMUXO_D; // RX

    // 3. Настраиваем UART
    uart.begin(9600);

    // 4. Отправляем данные
    uart.print("I2C data received: ");
    for (uint8_t i = 0; i < buffer_index; i++) {
        uart.write(i2c_buffer[i]);
    }
    uart.write('\n');

    for (volatile uint32_t delay = 0; delay < 500000; delay++);  // Короткая пауза для отладки
    switch_sercom5_to_i2c();
}

void switch_sercom5_to_i2c() {
    // 1. Отключаем UART
    uart.end();
    
    // 2. Переназначаем пины I2C (PA22 SDA, PA23 SCL)
    PORT->Group[0].PINCFG[22].bit.PMUXEN = 1;
    PORT->Group[0].PMUX[22 >> 1].reg |= PORT_PMUX_PMUXE_C; // SDA
    PORT->Group[0].PINCFG[23].bit.PMUXEN = 1;
    PORT->Group[0].PMUX[23 >> 1].reg |= PORT_PMUX_PMUXO_C; // SCL

    // 3. Запускаем I2C заново
    i2c.setSlave(I2C_SLAVE_ADDR);
}

int main(void) {
    SystemInit();
    switch_sercom5_to_i2c();
    uart.begin(9600);  // UART запускаем сразу для логов
    uart.print("System started\n");

    NVIC_EnableIRQ(SERCOM5_IRQn);  // Включаем прерывания SERCOM5

    while (1) {
        if (data_received) {
            uart.print("Switching to UART\n");
            data_received = false;
            switch_sercom5_to_uart();
        }
    }
}
