#include <asf.h>
#include "SEGGER_RTT.h"

#define I2C_SLAVE_ADDRESS 0x10 // I2C Slave Address

volatile uint8_t i2c_received_data[16];
volatile uint8_t i2c_index = 0;

struct i2c_slave_module i2c_slave_instance;

void configure_i2c_slave(void) {
    struct i2c_slave_config config;
    i2c_slave_get_config_defaults(&config);

    config.address = I2C_SLAVE_ADDRESS;
    config.address_mode = I2C_SLAVE_ADDRESS_MODE_MASK;

    i2c_slave_init(&i2c_slave_instance, SERCOM3, &config);
    i2c_slave_enable(&i2c_slave_instance);

    SEGGER_RTT_WriteString(0, "I2C Slave configured on SERCOM3\n");
}

void i2c_slave_callback(struct i2c_slave_module *const module) {
    uint8_t received_byte = 0;

    // Чтение данных
    if (i2c_slave_read_packet_wait(module, &received_byte) == STATUS_OK) {
        SEGGER_RTT_printf(0, "Received: 0x%02X\n", received_byte);

        i2c_received_data[i2c_index++] = received_byte;
        if (i2c_index >= sizeof(i2c_received_data)) {
            i2c_index = 0;
        }

        // Ответ
        uint8_t response = 0xAA;
        i2c_slave_write_packet_wait(module, &response);
    }
}

void configure_i2c_callbacks(void) {
    i2c_slave_register_callback(&i2c_slave_instance, i2c_slave_callback, I2C_SLAVE_CALLBACK_READ_COMPLETE);
    i2c_slave_enable_callback(&i2c_slave_instance, I2C_SLAVE_CALLBACK_READ_COMPLETE);
}

int main(void) {
    system_init();
    SEGGER_RTT_Init();
    SEGGER_RTT_WriteString(0, "I2C Slave Initialized\n");

    configure_i2c_slave();
    configure_i2c_callbacks();

    while (1) {
        __WFI();
    }
}
