int I2C::slave_write_packet_wait(uint8_t *buf, uint8_t len)
{
  	if(isMaster())setSlave(slaveAddr);
	i2c_slave_wait_for_bus();
	if (!(sercom->I2CS.STATUS.reg & SERCOM_I2CS_STATUS_DIR)) {
		// Write request from master, send NACK and return
		i2c_slave_set_ctrlb_ackact(false);
		i2c_slave_set_ctrlb_cmd3();
		return -1;
	}	
	i2c_slave_set_ctrlb_ackact(true);
	i2c_slave_set_ctrlb_cmd3();  
  	i2c_slave_wait_for_bus();
	uint16_t i = 0;
	uint16_t length = len;
	while (length--) {
	  	while (sercom->I2CS.STATUS.bit.SYNCBUSY){}
		sercom->I2CS.DATA.reg = buf[i++];
		i2c_slave_wait_for_bus();
		if (sercom->I2CS.STATUS.reg & SERCOM_I2CS_STATUS_RXNACK &&	length !=0) {
			// NACK from master, abort
			// Release line
			sercom->I2CS.CTRLB.reg |= SERCOM_I2CS_CTRLB_CMD(0x02);			
			return -2;
		}
	}
	sercom->I2CS.CTRLB.reg |= SERCOM_I2CS_CTRLB_CMD(0x02);	
	return 0;
}
