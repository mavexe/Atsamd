#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>

// Реализация _sbrk
extern uint32_t _end;  // Конец секции .bss
extern uint32_t _estack;  // Начало стека

void* _sbrk(intptr_t increment) {
    static uint8_t* heap_end = (uint8_t*)&_end;  // Текущий конец кучи
    uint8_t* prev_heap_end = heap_end;

    // Проверка на переполнение кучи
    if (heap_end + increment > (uint8_t*)&_estack) {
        errno = ENOMEM;
        return (void*)-1;
    }

    // Увеличиваем кучу
    heap_end += increment;

    return (void*)prev_heap_end;
}

// Создаем объект SERCOM для SERCOM5
SERCOM sercom5 = SERCOM(SERCOM5);

// Создаем объект UART для SERCOM5
Uart uart(&sercom5, PIN_PA20, PIN_PA21, SERCOM_RX_PAD_3, UART_TX_PAD_2);

// Обработчик прерываний для SERCOM5
void SERCOM5_Handler() {
    uart.IrqHandler();  // Обработчик прерываний для UART
}

int main(void) {
    // Инициализация системы
    SystemInit();

    // Инициализация UART на скорости 9600 бод
    uart.begin(9600);

    // Вывод сообщения о готовности
    uart.write((uint8_t*)"UART initialized. Starting counter...\n", 37);

    // Переменная-счетчик
    uint32_t counter = 0;

    // Основной цикл программы
    while (1) {
        // Форматируем строку в буфер
        char buffer[128];
        int len = snprintf(buffer, sizeof(buffer), "Counter: %lu\n", counter);

        // Отправляем строку через UART
        uart.write((uint8_t*)buffer, len);

        // Увеличиваем счетчик на 1
        counter++;

        // Задержка 1 секунда
        for (volatile int i = 0; i < 1000000; i++);  // Простая задержка
    }

    return 0;  // Программа никогда не дойдет до этой строки
}
