#define I2C_SLAVE_ADDRESS 0x10
#define SYSTEM_CORE_CLOCK 1000000 // 1 MHz

void init_i2c_slave(Sercom *sercom) {
    // Enable GCLK for the respective SERCOM
    uint8_t sercom_id = (uint8_t)((uintptr_t)sercom - (uintptr_t)SERCOM0) / sizeof(Sercom);
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM0_GCLK_ID_CORE + sercom_id) |
                        GCLK_CLKCTRL_GEN(0) | // Generic Clock Generator 0
                        GCLK_CLKCTRL_CLKEN;
    while (GCLK->STATUS.bit.SYNCBUSY);

    // Reset the SERCOM instance
    sercom->I2CS.CTRLA.reg = SERCOM_I2CS_CTRLA_SWRST;
    while (sercom->I2CS.CTRLA.bit.SWRST);

    // Configure as I2C Slave
    sercom->I2CS.CTRLA.reg = SERCOM_I2CS_CTRLA_MODE_I2C_SLAVE |
                             SERCOM_I2CS_CTRLA_ENABLE;
    sercom->I2CS.ADDR.reg = SERCOM_I2CS_ADDR_ADDR(I2C_SLAVE_ADDRESS);
}

void init_uart(void) {
    // Enable GCLK for SERCOM5
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM5_GCLK_ID_CORE) |
                        GCLK_CLKCTRL_GEN(0) | // Generic Clock Generator 0
                        GCLK_CLKCTRL_CLKEN;
    while (GCLK->STATUS.bit.SYNCBUSY);

    // Configure SERCOM5 pins for UART (PA20 TX, PA21 RX)
    PORT->Group[0].PINCFG[20].reg = PORT_PINCFG_PMUXEN;
    PORT->Group[0].PINCFG[21].reg = PORT_PINCFG_PMUXEN;
    PORT->Group[0].PMUX[10].reg = PORT_PMUX_PMUXE_C | PORT_PMUX_PMUXO_C;

    // Reset SERCOM5
    SERCOM5->USART.CTRLA.reg = SERCOM_USART_CTRLA_SWRST;
    while (SERCOM5->USART.CTRLA.bit.SWRST);

    // Configure SERCOM5 as UART
    SERCOM5->USART.CTRLA.reg = SERCOM_USART_CTRLA_DORD | // LSB first
                               SERCOM_USART_CTRLA_MODE_USART_INT_CLK | // Internal clock
                               (3 << SERCOM_USART_CTRLA_RXPO_Pos) | // RX on PAD[3] (PA21)
                               (1 << SERCOM_USART_CTRLA_TXPO_Pos);  // TX on PAD[1] (PA20)

    SERCOM5->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | // Enable RX
                               SERCOM_USART_CTRLB_TXEN;  // Enable TX

    // Baud rate configuration (assuming 1MHz clock, 19200 baud)
    SERCOM5->USART.BAUD.reg = (uint16_t)(65536 * (1 - ((16.0 * 19200) / SYSTEM_CORE_CLOCK)));

    // Enable SERCOM5
    SERCOM5->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
}

void uart_write(uint8_t data) {
    while (!(SERCOM5->USART.INTFLAG.bit.DRE)); // Wait until Data Register Empty
    SERCOM5->USART.DATA.reg = data;
}

void i2c_slave_handler(Sercom *sercom) {
    if (sercom->I2CS.INTFLAG.bit.DRDY) {
        // Data Ready
        uint8_t received_data = sercom->I2CS.DATA.reg;
        uart_write(received_data); // Transmit received data over UART
    }

    if (sercom->I2CS.INTFLAG.bit.AMATCH) {
        // Address Match
        sercom->I2CS.STATUS.reg = SERCOM_I2CS_STATUS_AMATCH; // Clear address match
    }

    if (sercom->I2CS.INTFLAG.bit.PREC) {
        // Stop Condition Received
        sercom->I2CS.STATUS.reg = SERCOM_I2CS_STATUS_PREC; // Clear stop condition
    }
}

int main(void) {
    SystemInit();

    // Initialize all I2C slave SERCOMs
    init_i2c_slave(SERCOM0);
    init_i2c_slave(SERCOM1);
    init_i2c_slave(SERCOM2);
    init_i2c_slave(SERCOM3);
    init_i2c_slave(SERCOM4);

    // Initialize UART on SERCOM5
    init_uart();

    while (1) {
        i2c_slave_handler(SERCOM0);
        i2c_slave_handler(SERCOM1);
        i2c_slave_handler(SERCOM2);
        i2c_slave_handler(SERCOM3);
        i2c_slave_handler(SERCOM4);
    }
}
