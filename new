#include <sam.h>

#define I2C_SLAVE_ADDRESS 0x10
#define SYSTEM_CORE_CLOCK 1000000 // 1 MHz

void init_i2c_slave(void) {
    // Enable GCLK for SERCOM1
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM1_GCLK_ID_CORE) |
                        GCLK_CLKCTRL_GEN(0) | // Generic Clock Generator 0
                        GCLK_CLKCTRL_CLKEN;
    while (GCLK->STATUS.bit.SYNCBUSY);

    // Configure SERCOM1 pins for I2C (PA16 SDA, PA17 SCL)
    PORT->Group[0].PINCFG[16].reg = PORT_PINCFG_PMUXEN;
    PORT->Group[0].PINCFG[17].reg = PORT_PINCFG_PMUXEN;
    PORT->Group[0].PMUX[8].reg = PORT_PMUX_PMUXE_C | PORT_PMUX_PMUXO_C;

    // Reset SERCOM1
    SERCOM1->I2CS.CTRLA.reg = SERCOM_I2CS_CTRLA_SWRST;
    while (SERCOM1->I2CS.CTRLA.bit.SWRST);

    // Configure SERCOM1 as I2C Slave
    SERCOM1->I2CS.CTRLA.reg = SERCOM_I2CS_CTRLA_MODE_I2C_SLAVE;
    SERCOM1->I2CS.ADDR.reg = SERCOM_I2CS_ADDR_ADDR(I2C_SLAVE_ADDRESS);

    // Enable SERCOM1
    SERCOM1->I2CS.CTRLA.reg |= SERCOM_I2CS_CTRLA_ENABLE;
}

void init_uart(void) {
    // Enable GCLK for SERCOM5
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(SERCOM5_GCLK_ID_CORE) |
                        GCLK_CLKCTRL_GEN(0) | // Generic Clock Generator 0
                        GCLK_CLKCTRL_CLKEN;
    while (GCLK->STATUS.bit.SYNCBUSY);

    // Configure SERCOM5 pins for UART (PA20 TX, PA21 RX)
    PORT->Group[0].PINCFG[20].reg = PORT_PINCFG_PMUXEN;
    PORT->Group[0].PINCFG[21].reg = PORT_PINCFG_PMUXEN;
    PORT->Group[0].PMUX[10].reg = PORT_PMUX_PMUXE_C | PORT_PMUX_PMUXO_C;

    // Reset SERCOM5
    SERCOM5->USART.CTRLA.reg = SERCOM_USART_CTRLA_SWRST;
    while (SERCOM5->USART.CTRLA.bit.SWRST);

    // Configure SERCOM5 as UART
    SERCOM5->USART.CTRLA.reg = SERCOM_USART_CTRLA_DORD | // LSB first
                               SERCOM_USART_CTRLA_MODE_USART_INT_CLK | // Internal clock
                               SERCOM_USART_CTRLA_RXPO(_U_(0x3)) | // RX on PAD[3] (PA21)
                               SERCOM_USART_CTRLA_TXPO(_U_(0x1));  // TX on PAD[1] (PA20)

    SERCOM5->USART.CTRLB.reg = SERCOM_USART_CTRLB_RXEN | // Enable RX
                               SERCOM_USART_CTRLB_TXEN;  // Enable TX

    // Baud rate configuration (assuming 1MHz clock, 19200 baud)
    SERCOM5->USART.BAUD.reg = (uint16_t)(65536 * (1 - ((16.0 * 19200) / SYSTEM_CORE_CLOCK)));

    // Enable SERCOM5
    SERCOM5->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
}

void uart_write(uint8_t data) {
    while (!(SERCOM5->USART.INTFLAG.bit.DRE)); // Wait until Data Register Empty
    SERCOM5->USART.DATA.reg = data;
}

void i2c_slave_handler(void) {
    if (SERCOM1->I2CS.INTFLAG.bit.DRDY) {
        // Data Ready
        uint8_t received_data = SERCOM1->I2CS.DATA.reg;
        uart_write(received_data); // Transmit received data over UART
    }

    if (SERCOM1->I2CS.INTFLAG.bit.AMATCH) {
        // Address Match
        SERCOM1->I2CS.STATUS.reg |= SERCOM_I2CS_STATUS_AMATCH;
    }

    if (SERCOM1->I2CS.INTFLAG.bit.PREC) {
        // Stop Condition Received
        SERCOM1->I2CS.STATUS.reg |= SERCOM_I2CS_STATUS_PREC;
    }
}

int main(void) {
    SystemInit();

    init_i2c_slave();
    init_uart();

    while (1) {
        i2c_slave_handler();
    }
}
